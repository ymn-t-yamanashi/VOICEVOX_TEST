<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>VOICEVOX TTS (ãƒ­ãƒ¼ã‚«ãƒ«API)</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
        }
        textarea {
            width: 100%;
            height: 100px;
            margin-bottom: 10px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 8px;
        }
        .status {
            margin-top: 10px;
            font-weight: bold;
        }
        .audio-area {
            margin-top: 5px; /* ã‚¹ãƒšãƒ¼ã‚¹ã‚’å°‘ã—è©°ã‚ã‚‹ */
        }
        /* ğŸŒŸ ã“ã“ãŒå¤‰æ›´ç‚¹: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’éè¡¨ç¤ºã«ã™ã‚‹ ğŸŒŸ */
        #audio-player {
            display: none; 
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>VOICEVOX ãƒ†ã‚­ã‚¹ãƒˆèª­ã¿ä¸Šã’</h1>
        <p>ãƒ­ãƒ¼ã‚«ãƒ«ã§Dockerèµ·å‹•ã—ãŸVOICEVOX Engine (50021ãƒãƒ¼ãƒˆ) ã«æ¥ç¶šã—ã€éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†ç”Ÿã—ã¾ã™ã€‚</p>

        <label for="speaker-select">è©±è€…é¸æŠ:</label>
        <select id="speaker-select">
            <option value="3">å››å›½ã‚ãŸã‚“ (ãƒãƒ¼ãƒãƒ«)</option>
            <option value="2">ãšã‚“ã ã‚‚ã‚“ (ãƒãƒ¼ãƒãƒ«)</option>
            <option value="4">æ˜¥æ—¥éƒ¨ã¤ã‚€ã (ãƒãƒ¼ãƒãƒ«)</option>
        </select>
        <br><br>
        
        <textarea id="text-input" placeholder="ã“ã“ã«å–‹ã‚‰ã›ãŸã„ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„" required>ã“ã‚“ã«ã¡ã¯ã€VOICEVOXã®å†ç”Ÿãƒ†ã‚¹ãƒˆã§ã™ã€‚</textarea>
        
        <button id="speak-button" onclick="speakText()">å–‹ã‚‰ã›ã‚‹</button>
        <p class="status" id="status-message">æº–å‚™å®Œäº†</p>
        
        <div class="audio-area">
            <audio id="audio-player" controls></audio>
        </div>
    </div>

    <script>
        const VOICEVOX_URL = "http://localhost:50021"; // VOICEVOX Engineã®URL
        const textInput = document.getElementById('text-input');
        const speakerSelect = document.getElementById('speaker-select');
        const speakButton = document.getElementById('speak-button');
        const statusMessage = document.getElementById('status-message');
        const audioPlayer = document.getElementById('audio-player');
        
        /**
         * ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ›´æ–°ã—ã¾ã™
         */
        function updateStatus(message, color = 'black') {
            statusMessage.textContent = message;
            statusMessage.style.color = color;
        }

        /**
         * ãƒ†ã‚­ã‚¹ãƒˆã‚’éŸ³å£°ã«å¤‰æ›ã—ã¦å†ç”Ÿã—ã¾ã™
         */
        async function speakText() {
            const text = textInput.value.trim();
            const speakerId = speakerSelect.value;

            if (!text) {
                updateStatus("ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚", 'orange');
                return;
            }

            speakButton.disabled = true;
            audioPlayer.removeAttribute('src'); // å‰ã®éŸ³å£°ã‚’ã‚¯ãƒªã‚¢

            updateStatus("éŸ³å£°ã‚¯ã‚¨ãƒªã‚’ä½œæˆä¸­...", 'blue');

            try {
                // 1. **éŸ³å£°åˆæˆã‚¯ã‚¨ãƒª**ã®ä½œæˆ (audio_query)
                const queryParams = new URLSearchParams({
                    text: text,
                    speaker: speakerId
                });
                const queryUrl = `${VOICEVOX_URL}/audio_query?${queryParams}`;

                const queryResponse = await fetch(queryUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (!queryResponse.ok) {
                    throw new Error(`audio_query failed with status ${queryResponse.status}`);
                }

                const audioQuery = await queryResponse.json();
                
                updateStatus("éŸ³å£°åˆæˆä¸­...", 'blue');

                // 2. **éŸ³å£°åˆæˆ**ã®å®Ÿè¡Œ (synthesis)
                const synthesisParams = new URLSearchParams({
                    speaker: speakerId
                });
                const synthesisUrl = `${VOICEVOX_URL}/synthesis?${synthesisParams}`;

                const synthesisResponse = await fetch(synthesisUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(audioQuery)
                });

                if (!synthesisResponse.ok) {
                    throw new Error(`synthesis failed with status ${synthesisResponse.status}`);
                }

                // 3. **éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã¨HTML Audio Playerã«ã‚ˆã‚‹å†ç”Ÿ**
                const wavBlob = await synthesisResponse.blob();
                
                // Blobã‹ã‚‰ä¸€æ™‚çš„ãªURLã‚’ä½œæˆã—ã€audioè¦ç´ ã®srcã«è¨­å®š
                const audioUrl = URL.createObjectURL(wavBlob);
                audioPlayer.src = audioUrl;

                // å†ç”Ÿé–‹å§‹
                await audioPlayer.play();

                updateStatus("å†ç”Ÿä¸­ã§ã™ã€‚", 'green');
                
                // å†ç”ŸãŒçµ‚äº†ã—ãŸã‚‰ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹ã«æˆ»ã™
                audioPlayer.onended = () => {
                    updateStatus("å†ç”ŸãŒå®Œäº†ã—ã¾ã—ãŸã€‚", 'black');
                    speakButton.disabled = false;
                };

            } catch (error) {
                console.error("VOICEVOX APIã‚¨ãƒ©ãƒ¼ã¾ãŸã¯å†ç”Ÿã‚¨ãƒ©ãƒ¼:", error);
                if (error.name === "NotAllowedError") {
                    // éè¡¨ç¤ºã§ã‚‚è‡ªå‹•å†ç”Ÿã¯ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€ã“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ç¶­æŒ
                    updateStatus("å†ç”ŸãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚", 'orange');
                } else {
                    updateStatus(`ã‚¨ãƒ©ãƒ¼: VOICEVOX Engineã«æ¥ç¶šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ãƒãƒ¼ãƒˆ (${VOICEVOX_URL}) ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`, 'red');
                }
                speakButton.disabled = false;
            } 
        }

        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«è©±è€…ãƒªã‚¹ãƒˆã‚’å–å¾—ã™ã‚‹å‡¦ç†ï¼ˆå¤‰æ›´ãªã—ï¼‰
        async function fetchSpeakers() {
            try {
                const response = await fetch(`${VOICEVOX_URL}/speakers`);
                if (response.ok) {
                    const speakers = await response.json();
                    console.log("åˆ©ç”¨å¯èƒ½ãªè©±è€…ãƒ‡ãƒ¼ã‚¿:", speakers);
                } else {
                    console.warn("è©±è€…ãƒªã‚¹ãƒˆã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè©±è€…ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚");
                }
            } catch (e) {
                console.error("VOICEVOX Engineã¸ã®æ¥ç¶šã‚¨ãƒ©ãƒ¼:", e);
            }
        }

        fetchSpeakers();
    </script>
</body>
</html>